import { useState, useEffect } from "react";

function App() {
  const [exchangeData, setExchangeData] = useState({});
  const [exchange2Data, setExchange2Data] = useState({});
  // eslint-disable-next-line no-unused-vars
  const [bankData, setBankData] = useState({});

  useEffect(function () {
    setExchangeData({
      returns: 100,
    });
  }, []);

  useEffect(function () {
    setExchange2Data({
      returns: 200,
    });
  }, []);

  useEffect(function () {
    setTimeout(function () {
      setBankData({
        income: 300,
      });
    }, 3000);
  }, []);

  const calculateCryptoReturns = function () {
    return exchangeData.returns + exchange2Data.returns;
  };

  // const incomeTax = (calculateCryptoReturns() + bankData.income) * 0.3;

  return (
    <div>
      <CryptoGainsCalculator calculateCryptoReturns={calculateCryptoReturns} />
    </div>
  );
}

// eslint-disable-next-line react/prop-types
function CryptoGainsCalculator({ calculateCryptoReturns }) {
  console.log("Crypto child re-renders");
  return <div>Your crypto returns are {calculateCryptoReturns()}</div>;
}

export default App;

// useCallback is about not rendering a child, if function doesn't need to change across renders.
// It is not about minimizing amount of code to be run.

// Anytime a parent re-renders, its child component is bound to re-render
// This is true until we introduce memo. Memo is different from useMemo.
//  Memo helps you to skip re-rendering a component when its props are unchanged.